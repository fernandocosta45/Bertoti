ATIVIDADE 1: Comentar com suas palavras o primeiro trecho do livro Software Engineering at Google, Oreilly. (primeiro post)
Esse trecho do livro destaca a diferença entre “programação” e “engenharia de software”. A programação é vista como a atividade de escrever código, enquanto a engenharia de software envolve aplicar princípios teóricos e práticas estruturadas para construir sistemas confiáveis e sustentáveis. A comparação com outras engenharias mostra que, embora o software seja menos tangível, ele também precisa de rigor, já que erros podem ter impacto significativo na vida das pessoas. O argumento central é que, com a crescente integração do software em nosso cotidiano, torna-se indispensável adotar métodos mais disciplinados e robustos, e a proposta do livro é justamente indicar caminhos para práticas mais confiáveis.

ATIVIDADE 2: Comentar com suas palavras o segundo trecho do livro Software Engineering at Google, Oreilly.(segundo post)
Esse trecho amplia a definição de engenharia de software, mostrando que ela não se limita ao ato de programar, mas envolve práticas, ferramentas e processos que garantem a manutenção e evolução do código ao longo do tempo. A ideia central é que “engenharia de software” pode ser entendida como “programação integrada ao longo do tempo”, ou seja, um esforço contínuo para manter o código sustentável e adaptável às mudanças inevitáveis. O livro destaca três princípios fundamentais que devem orientar organizações de software: Tempo e mudança: o código precisa estar preparado para evoluir durante seu ciclo de vida - Escala e crescimento: a organização deve se adaptar conforme aumenta em tamanho e complexidade - Trade-offs e custos: decisões técnicas e organizacionais devem considerar impactos e compromissos, sempre equilibrando benefícios e riscos. Em síntese, o trecho reforça que a engenharia de software é sobre construir sistemas duradouros, capazes de acompanhar tanto a evolução tecnológica quanto as necessidades da organização.

ATIVIDADE 3: Requisitos não funcionais
Listar 5 requisitos não funcionais e descrevê-los com suas palavras

1. Desempenho: define como o sistema responde em termos de tempo e eficiência.
   Descrição: especifica limites aceitáveis para tempo de resposta, taxa de processamento, uso de CPU, memória ou largura de banda. Ex: o sistema deve responder às requisições do usuário em até 2 segundos.
2. Segurança: relaciona-se à proteção das informações e do sistema.
   Descrição: garante confidencialidade, integridade e autenticidade dos dados, incluindo controle de acesso, criptografia e auditoria. Ex: apenas usuários autenticados podem acessar dados financeiros.
3. Usabilidade: trata da facilidade de uso do sistema pelos usuários.
   Descriçãp: avalia o quão intuitiva, acessível e fácil de aprender é a interface, considerando o público-alvo. Ex: um novo usuário deve conseguir realizar uma operação básica sem treinamento prévio.
4. Confiabilidade: indica o grau de estabilidade e disponibilidade do sistema.
   Descrição: define a capacidade do software de funcionar corretamente por um período de tempo, mesmo diante de falhas. Ex: o sistema deve estar disponível 99,9% do tempo.
5. Escalabilidade: refere-se à capacidade de um sistema crescer e se adaptar ao aumento da demanda sem perder desempenho ou qualidade. Descrição: é a propriedade que garante que o sistema continue funcionando de forma eficiente quando o número de usuários, transações ou volume de dados aumenta. Ex: imagine uma loja online que recebe 1.000 acessos por dia normalmente, mas na Black Friday esse número sobe para 100.000. Um sistema escalável consegue lidar com esse aumento sem travar, mantendo o tempo de resposta rápido e a disponibilidade alta.

ATIVIDADE 4: Trade-offs (negociação entre requisitos não funcionais)
Citar e descrever 3 cenários de trade-offs:

1. Velocidade de entrega vs. Qualidade do código
Descrição: Entregar rapidamente uma funcionalidade pode ser essencial para atender prazos ou aproveitar oportunidades de mercado.
Custo: O código pode ficar menos estruturado, dificultando manutenção futura.
Benefício: Ganho imediato em tempo e competitividade.

2. Performance vs. Legibilidade
Descrição: Otimizar ao máximo o desempenho pode levar a soluções complexas e difíceis de entender.
Custo: Aumenta a curva de aprendizado e dificulta correções.
Benefício: Melhor resposta do sistema em cenários críticos de uso intensivo.

3. Generalização vs. Simplicidade
Descrição: Criar soluções genéricas e reutilizáveis aumenta a flexibilidade.
Custo: Pode tornar o código mais abstrato e complicado para casos simples.
Benefício: Facilita adaptações futuras e reduz duplicação de esforço.

Esses exemplos mostram que cada decisão técnica envolve compromissos: ao ganhar em um aspecto, geralmente se perde em outro.
